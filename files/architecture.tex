\chapter{Architecture}
This chapter describes the architecture used in the project.

\section{Domain model}
Given the above introduction a domain model was derived, figure \ref{fig:domainModel}, to make the domain entity relations visible.
This is done to make sure the understanding of the relations are clear before doing any further development.
It is important to note that this is a tentative model and as long as the project is under development, it is subject to change.

\graphic{1}{domain_model}{Domain model}{fig:domainModel}

\section{Framework architecture}
Multiple frameworks are used in the project. 
This is a short description of the tasks each framework is responsible for. 
An overview is shown on figure \ref{frameworkArchitecture}.

At the application layer of the front-end \gls{ng2} is responsible for the view rendering and business logic. 
It communicates with the \gls{apollo:client}, that is responsible for communicating with the back-end, as well as holding application state. 
Between the front-end and back-end the \gls{api} is defined with \gls{graphql}.

The client application layer is run with the \gls{nativescript} run-time. 
At compile time, the \gls{ng2} views and styling is rendered to native UI elements and styling. 
The application logic is held in JavaScript and run on a platform specific JavaScript engine, i.e. \gls{v8} for Android and \gls{javascriptcore} for iOS.

On the back-end the application layer is an \gls{apollo:server} instance. 
This is the counter part to the \gls{apollo:client} and provides the reactive data system. 
It further defines the \gls{api} for collecting data from databases like \gls{mongodb}, as this project utilizes.
Both of these frameworks run on the \gls{node} run-time, which in turn runs on the \gls{v8} JavaScript engine.

\graphic{0.9}{frameworkArchitecture}{Framework architecture overview}{frameworkArchitecture}

\input{files/N+1/index}
